;;; cider-eval-in-org-mode.el --- Evaluate Clojure through CIDER REPL in org-mode

;; Keywords: org-mode, literate programming, clojure, cider

;;; Commentary:
;; This code was generated by Claude 3.7 Sonnet, refactored by 3.5 Haiku. So
;; it's likely to be bloated
;;
;; No tests at the moment

;;; Code:

(require 'org)
(require 'org-element)
(require 'cl-lib)

(defun org-code-block-extract-block-info (src-block)
  "Extract relevant information from a source block.
SRC-BLOCK is an org-element source block."
  (let* ((properties (org-element-property :parameters src-block))
         (noweb-ref (when (string-match ":noweb-ref +\\([^ ]+\\)" properties)
                      (match-string 1 properties)))
         (tangle (when (string-match ":tangle +\\([^ ]+\\)" properties)
                   (match-string 1 properties)))
         (body (org-element-property :value src-block))
         (block-name (or noweb-ref tangle)))
    (when block-name
      (list :name block-name
            :noweb-ref noweb-ref
            :tangle tangle
            :body body))))

(defun org-code-block-find-noweb-references (block blocks)
  "Find noweb references for a given BLOCK in a list of BLOCKS."
  (let ((outgoing-edges '()))
    (dolist (ref-block blocks)
      (let ((ref-name (plist-get ref-block :noweb-ref)))
        (when (and ref-name
                   (string-match (format "<<%s>>" ref-name)
                                 (plist-get block :body)))
          (push ref-name outgoing-edges))))
    outgoing-edges))

(defun org-code-block-graph-buffer ()
  "Analyze the current org buffer and return code block relationships.
Returns an adjacency list representing noweb inclusion relationships."
  (save-excursion
    (save-restriction
      (widen)
      (let* ((blocks (delq nil
                      (org-element-map (org-element-parse-buffer) 'src-block
                        #'org-code-block-extract-block-info)))
             (adjacency-list '()))
        (dolist (block blocks)
          (let* ((block-name (plist-get block :name))
                 (outgoing-edges (org-code-block-find-noweb-references
                                  block blocks)))
            (push (cons block-name outgoing-edges) adjacency-list)))
        adjacency-list))))

(defun org-get-block-headers-at-point ()
  "Extract noweb-ref and tangle headers for the source block at point."
  (let ((element (org-element-at-point)))
    (when (eq (org-element-type element) 'src-block)
      (let* ((params (org-element-property :parameters element))
             (noweb-ref (when (string-match ":noweb-ref +\\([^ ]+\\)" params)
                          (match-string 1 params)))
             (tangle (when (string-match ":tangle +\\([^ ]+\\)" params)
                       (match-string 1 params))))
        (list :noweb-ref noweb-ref :tangle tangle)))))

(defun org-is-tangle-root-node (node graph)
  "Determine if NODE is a root node in the dependency GRAPH.
A root node has no parents and is not a noweb-ref-only node."
  (let ((is-root t))
    (dolist (entry graph)
      (let ((parent-name (car entry))
            (children (cdr entry)))
        (when (member node children)
          (setq is-root nil))))
    (and is-root (not (org-is-noweb-ref-only node graph)))))

(defun org-find-tangle-roots-for-block (block-name graph)
  "Find root :tangle files that include BLOCK-NAME.
Traverses the GRAPH to find paths from the given block to root nodes."
  (let ((result '())
        (visited '()))
    (cl-labels
        ((find-roots
          (node)
          (unless (member node visited)
            (push node visited)
            (when (org-is-tangle-root-node node graph)
              (push node result))
            (dolist (entry graph)
              (let ((parent-name (car entry))
                    (children (cdr entry)))
                (when (member node children)
                  (find-roots parent-name)))))))
      (find-roots block-name)
      result)))

(defun org-is-noweb-ref-only (node-name graph)
  "Check if NODE-NAME only has a :noweb-ref without a :tangle header."
  (let ((is-noweb-ref-only t))
    (save-excursion
      (save-restriction
        (widen)
        (goto-char (point-min))
        (while (and is-noweb-ref-only
                    (re-search-forward
                     (format "\\(:noweb-ref\\|:tangle\\) +%s\\>" node-name)
                     nil t))
          (let ((element (org-element-at-point)))
            (when (eq (org-element-type element) 'src-block)
              (let* ((params (org-element-property :parameters element))
                     (has-tangle
                      (string-match
                       (format ":tangle +%s\\>" node-name) params)))
                (when has-tangle
                  (setq is-noweb-ref-only nil))))))))
    is-noweb-ref-only))

(defun org-cider-find-ns-from-tangle-file (filename)
  "Find the namespace in a Clojure file specified by FILENAME."
  (when (and filename (not (string-empty-p filename)))
    (with-temp-buffer
      (condition-case nil
          (progn
            (insert-file-contents filename)
            (clojure-mode)
            (clojure-find-ns))
        (error nil)))))

(defun org-cider-is-clojure-source-block ()
  "Check if the current point is in a Clojure-related source block."
  (let* ((element (org-element-at-point))
         (is-src-block (eq (org-element-type element) 'src-block))
         (lang (when is-src-block
                 (org-element-property :language element))))
    (and is-src-block
         (member lang '("clojure" "clj" "cljs" "cljc")))))

(defun org-cider-get-tangle-namespace (headers)
  "Extract namespace from tangle headers.
HEADERS is a plist containing block header information."
  (when headers
    (or
     (and (plist-get headers :tangle)
          (org-cider-find-ns-from-tangle-file
           (plist-get headers :tangle)))
     (when (and (plist-get headers :noweb-ref)
                (fboundp 'org-code-block-graph-buffer)
                (fboundp 'org-find-tangle-roots-for-block))
       (let* ((graph (org-code-block-graph-buffer))
              (roots (org-find-tangle-roots-for-block
                      (plist-get headers :noweb-ref)
                      graph)))
         (when (car roots)
           (org-cider-find-ns-from-tangle-file
            (car roots))))))))

(defun org-cider-current-ns-advice (orig-fun &rest args)
  "Advice function for `cider-current-ns` that handles org-mode source blocks."
  (cond
   ((or (not (eq major-mode 'org-mode))
        (not (fboundp 'org-get-block-headers-at-point)))
    (apply orig-fun args))
   (t
    (save-excursion
      (cond
       ((org-cider-is-clojure-source-block)
        (let* ((headers (org-get-block-headers-at-point))
               (ns-from-tangle (org-cider-get-tangle-namespace headers)))
          (or ns-from-tangle (apply orig-fun args))))
       (t (apply orig-fun args)))))))

;;;###autoload
(defun display-org-code-block-graph ()
  "Display the code block relationship graph for the current org buffer."
  (interactive)
  (unless (eq major-mode 'org-mode)
    (user-error "This command only works in org-mode buffers"))

  (let ((graph (org-code-block-graph-buffer)))
    (cond
     ((null graph)
      (message "No code blocks with :noweb-ref or :tangle found in this buffer"))
     (t
      (with-current-buffer (get-buffer-create "*Org Code Block Graph*")
        (let ((inhibit-read-only t))
          (erase-buffer)
          (org-mode)
          (dolist (node (reverse graph))
            (let ((node-name (car node))
                  (edges (cdr node)))
              (insert (format "* %s\n" node-name))
              (if edges
                  (progn
                    (insert "  Includes blocks:\n")
                    (dolist (edge edges)
                      (insert (format "  - [[#%s][%s]]\n" edge edge))))
                (insert "  No blocks included\n"))
              (insert "\n")))
          (special-mode)
          (org-mode)
          (goto-char (point-min))
          (org-overview)
          (org-cycle-overview)
          (switch-to-buffer-other-window (current-buffer))))))))

;;;###autoload
(defun org-find-tangle-root-for-current-block ()
  "Find the tangle destination for the source block at point."
  (interactive)
  (unless (eq major-mode 'org-mode)
    (user-error "This command only works in org-mode buffers"))

  (let ((headers (org-get-block-headers-at-point)))
    (cond
     ((not headers)
      (message "Not in a source block"))
     (t
      (let ((noweb-ref (plist-get headers :noweb-ref))
            (tangle (plist-get headers :tangle)))
        (cond
         (tangle
          (message "Block will be directly tangled to: %s" tangle))
         (noweb-ref
          (let* ((graph (org-code-block-graph-buffer))
                 (root-files (org-find-tangle-roots-for-block noweb-ref graph)))
            (cond
             ((null root-files)
              (message "No root :tangle file found for %s" noweb-ref))
             ((= (length root-files) 1)
              (message "Block %s will be tangled to: %s"
                       noweb-ref
                       (car root-files)))
             (t
              (message "Block %s will be tangled to multiple files: %s"
                       noweb-ref
                       (mapconcat #'identity root-files ", "))))))
         (t
          (message "Block has neither :tangle nor :noweb-ref header"))))))))

;; Install the advice
(advice-add 'cider-current-ns :around #'org-cider-current-ns-advice)

(provide 'cider-eval-in-org-mode)
;;; org-code-block-tools.el ends here
